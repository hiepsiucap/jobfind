// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.9.0
// - protoc             v6.32.1
// source: notification/v1/notification.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationNotificationGetNotifications = "/api.notification.v1.Notification/GetNotifications"
const OperationNotificationGetUnreadCount = "/api.notification.v1.Notification/GetUnreadCount"
const OperationNotificationMarkAllAsRead = "/api.notification.v1.Notification/MarkAllAsRead"
const OperationNotificationMarkAsRead = "/api.notification.v1.Notification/MarkAsRead"

type NotificationHTTPServer interface {
	// GetNotifications Get user notifications with pagination
	GetNotifications(context.Context, *GetNotificationsRequest) (*GetNotificationsReply, error)
	// GetUnreadCount Get unread notification count
	GetUnreadCount(context.Context, *GetUnreadCountRequest) (*GetUnreadCountReply, error)
	// MarkAllAsRead Mark all notifications as read
	MarkAllAsRead(context.Context, *MarkAllAsReadRequest) (*MarkAllAsReadReply, error)
	// MarkAsRead Mark a notification as read
	MarkAsRead(context.Context, *MarkAsReadRequest) (*MarkAsReadReply, error)
}

func RegisterNotificationHTTPServer(s *http.Server, srv NotificationHTTPServer) {
	r := s.Route("/")
	r.GET("/api/v1/notifications", _Notification_GetNotifications0_HTTP_Handler(srv))
	r.GET("/api/v1/notifications/unread-count", _Notification_GetUnreadCount0_HTTP_Handler(srv))
	r.PUT("/api/v1/notifications/{notification_id}/read", _Notification_MarkAsRead0_HTTP_Handler(srv))
	r.PUT("/api/v1/notifications/read-all", _Notification_MarkAllAsRead0_HTTP_Handler(srv))
}

func _Notification_GetNotifications0_HTTP_Handler(srv NotificationHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetNotificationsRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationNotificationGetNotifications)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetNotifications(ctx, req.(*GetNotificationsRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetNotificationsReply)
		return ctx.Result(200, reply)
	}
}

func _Notification_GetUnreadCount0_HTTP_Handler(srv NotificationHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetUnreadCountRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationNotificationGetUnreadCount)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetUnreadCount(ctx, req.(*GetUnreadCountRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetUnreadCountReply)
		return ctx.Result(200, reply)
	}
}

func _Notification_MarkAsRead0_HTTP_Handler(srv NotificationHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in MarkAsReadRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationNotificationMarkAsRead)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.MarkAsRead(ctx, req.(*MarkAsReadRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*MarkAsReadReply)
		return ctx.Result(200, reply)
	}
}

func _Notification_MarkAllAsRead0_HTTP_Handler(srv NotificationHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in MarkAllAsReadRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationNotificationMarkAllAsRead)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.MarkAllAsRead(ctx, req.(*MarkAllAsReadRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*MarkAllAsReadReply)
		return ctx.Result(200, reply)
	}
}

type NotificationHTTPClient interface {
	// GetNotifications Get user notifications with pagination
	GetNotifications(ctx context.Context, req *GetNotificationsRequest, opts ...http.CallOption) (rsp *GetNotificationsReply, err error)
	// GetUnreadCount Get unread notification count
	GetUnreadCount(ctx context.Context, req *GetUnreadCountRequest, opts ...http.CallOption) (rsp *GetUnreadCountReply, err error)
	// MarkAllAsRead Mark all notifications as read
	MarkAllAsRead(ctx context.Context, req *MarkAllAsReadRequest, opts ...http.CallOption) (rsp *MarkAllAsReadReply, err error)
	// MarkAsRead Mark a notification as read
	MarkAsRead(ctx context.Context, req *MarkAsReadRequest, opts ...http.CallOption) (rsp *MarkAsReadReply, err error)
}

type NotificationHTTPClientImpl struct {
	cc *http.Client
}

func NewNotificationHTTPClient(client *http.Client) NotificationHTTPClient {
	return &NotificationHTTPClientImpl{client}
}

// GetNotifications Get user notifications with pagination
func (c *NotificationHTTPClientImpl) GetNotifications(ctx context.Context, in *GetNotificationsRequest, opts ...http.CallOption) (*GetNotificationsReply, error) {
	var out GetNotificationsReply
	pattern := "/api/v1/notifications"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationNotificationGetNotifications))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// GetUnreadCount Get unread notification count
func (c *NotificationHTTPClientImpl) GetUnreadCount(ctx context.Context, in *GetUnreadCountRequest, opts ...http.CallOption) (*GetUnreadCountReply, error) {
	var out GetUnreadCountReply
	pattern := "/api/v1/notifications/unread-count"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationNotificationGetUnreadCount))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// MarkAllAsRead Mark all notifications as read
func (c *NotificationHTTPClientImpl) MarkAllAsRead(ctx context.Context, in *MarkAllAsReadRequest, opts ...http.CallOption) (*MarkAllAsReadReply, error) {
	var out MarkAllAsReadReply
	pattern := "/api/v1/notifications/read-all"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationNotificationMarkAllAsRead))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// MarkAsRead Mark a notification as read
func (c *NotificationHTTPClientImpl) MarkAsRead(ctx context.Context, in *MarkAsReadRequest, opts ...http.CallOption) (*MarkAsReadReply, error) {
	var out MarkAsReadReply
	pattern := "/api/v1/notifications/{notification_id}/read"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationNotificationMarkAsRead))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
